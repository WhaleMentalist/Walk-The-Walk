package us.daniel.walkthewalk;

import android.content.Context;
import android.content.Intent;

import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;

import android.os.Handler;
import android.os.HandlerThread;

import android.support.v4.content.LocalBroadcastManager;

import android.util.Log;

import java.util.ArrayList;
import java.util.List;
import java.util.Observable;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static android.content.Context.SENSOR_SERVICE;

/**
 * A singleton based class that will allow the
 * processing of accelerometer based data to
 * detect foot step occurrences.
 */
public class AccelerometerProcessing extends Observable {

    private static final String DEBUG_TAG = "ACCELEROMETER_PROCESS";

    /** Will be used to subtract off magnitude calculated from sensor data */
    private static final float GRAVITY = 9.807f;

    /** The period between sensor readings in microseconds */
    private static final int SAMPLE_RATE = 20000;

    /** Number of seconds between each sample (NOTE: It is approximate, but good enough) */
    private static final float TIME_STEP = SAMPLE_RATE / 1000000.0f;

    /** Amount of sensor data samples to read*/
    private static final int SAMPLE_SIZE = 100;

    /** Threshold for when walking is started */
    private static final float THRESHOLD = 5.4f;

    /** The context of the service that starts this object*/
    private Context context;

    /** Allow the use of register and unregister the listener for accelerometer */
    private SensorManager sensorManager;

    /** The listener for sensor events generated by accelerometer */
    private AccelerometerListener accelerometerListener;

    /** The thread that will read acceleration values and populate the buffer */
    private HandlerThread accelerationReading;

    /** A runnable that will process the acceleration data and detect foot steps */
    private ExecutorService stepDetection;

    /** This will allow producer thread to notify the consumer thread for acceleration data */
    private CountDownLatch countDownLatch;

    /** This will queue data read from the sensor and also manage when it is read */
    private ArrayBlockingQueue<Float> acceleration;

    /** Number of steps detected */
    private int steps;

    /**
     * Holds a single instance of outer class. To enforce
     * singleton contract.
     */
    private static class AccelerometerProcessingHolder {
        private static final AccelerometerProcessing INSTANCE = new AccelerometerProcessing();
    }

    /**
     * Construct the necessary threads to process data and specify
     * the sample rate for sensor.
     */
    private AccelerometerProcessing() {}

    /**
     * Method allows pedometer service to send its step count to
     * the activities that are subscribed
     */
    private void sendMessageToActivity() {
        Intent intent = new Intent("PEDOMETER_STEP_UPDATE"); /** */
        intent.putExtra("step_count", steps);
        LocalBroadcastManager.getInstance(context).sendBroadcast(intent); /** Broadcast step count to interested components */
    }

    /**
     * Allows singleton instance to be given a context to connect to sensor
     * and read the data. If this method is NOT called then this object will not
     * do anything
     *
     * TODO: Read from persistent data. Allow tracking of exercise
     *
     * @param c the pedometer service context
     */
    public void setup(Context c) {
        Log.d(DEBUG_TAG, "Setup");
        context = c;
        sensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE);
        Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        acceleration = new ArrayBlockingQueue<>(2 * SAMPLE_SIZE);
        steps = 0;
        countDownLatch = new CountDownLatch(SAMPLE_SIZE);

        /** Create thread for sensor reading */
        accelerationReading = new HandlerThread("ACCELEROMETER_R", Thread.MAX_PRIORITY);
        accelerationReading.start();

        accelerometerListener = new AccelerometerListener();

        /** Register listener for accelerometer and place in its own thread */
        sensorManager.registerListener(accelerometerListener, accelerometer,
                SAMPLE_RATE, new Handler(accelerationReading.getLooper()));

        /** This will consume data that is produced by accelerometer*/
        stepDetection = Executors.newSingleThreadExecutor();
        stepDetection.submit(new AccelerationDataProcessing());
    }

    /**
     * TODO: Save data to allow persistent data
     */
    public void destroy() {
        Log.d(DEBUG_TAG, "Destroy");
        /** Shutdown running threads that process accelerometer data */
        accelerationReading.quitSafely();
        stepDetection.shutdown();

        /** Stop listening for events TODO: Even needed since we are shutting down threads? */
        sensorManager.unregisterListener(accelerometerListener);
    }

    /**
     * Returns the single instance created
     *
     * @return  the single instance allowed in application
     */
    public static AccelerometerProcessing getInstance() {
        return AccelerometerProcessingHolder.INSTANCE;
    }

    /**
     * Handles the accelerometer getting a new reading. This is considered the producer
     * in the producer-consumer problem
     */
    private class AccelerometerListener implements SensorEventListener {

        private static final String DEBUG_TAG = "ACCELEROMETER_READER";

        @Override
        public void onSensorChanged(SensorEvent sensorEvent) {

            float x, y, z, mag;
            x = sensorEvent.values[0];
            y = sensorEvent.values[1];
            z = sensorEvent.values[2];

            /** Want to subtract off the magnitude due to gravity*/
            mag = (float) Math.sqrt((double)(x * x + y * y + z * z)) - GRAVITY;

            try {
                acceleration.put(mag); /** Record into buffer for evaluation later */
                countDownLatch.countDown(); /** Bring down count down for other consumer thread*/
                Log.d(DEBUG_TAG, "Count down: " + countDownLatch.getCount());
            }
            catch(InterruptedException e) {
                Log.d(DEBUG_TAG, e.getMessage());
            }
        }

        @Override
        public void onAccuracyChanged(Sensor sensor, int i) {
            /** Empty for now */
        }
    }


    /**
     * Handles the processing of the accelerometer data. Since this is in another thread
     * this can be considered the consumer in the consumer-producer problem
     */
    private class AccelerationDataProcessing implements Runnable {

        private static final String DEBUG_TAG = "STEP_DETECTION";

        /** Determines if thread should keep running. Important during teardown */
        private volatile boolean execute = true;

        /** A copy of the sensor readings */
        private List<Float> sensorDataCopy = new ArrayList<>();

        /** Track state of step detection algorithm */
        private boolean aboveThreshold = false;

        /** Track if we are moving */
        private boolean moving = false;

        /** Track point the number of steps taken to detect the next step*/
        private long numberSamplesToStep;

        @Override
        public void run() {

            while(execute) { /** Allow thread to be stopped externally */

                try {
                    countDownLatch.await(); /** Wait until sample size is complete */
                    countDownLatch = new CountDownLatch(SAMPLE_SIZE); /** Reset count down*/
                }
                catch(InterruptedException e) {
                    Log.d(DEBUG_TAG, e.getMessage());
                }

                acceleration.drainTo(sensorDataCopy, SAMPLE_SIZE); /** Copy readings into data member */
                Log.d(DEBUG_TAG, "Copy Size: " + sensorDataCopy.size());
                Log.d(DEBUG_TAG, "Detecting steps");
                detectSteps(); /** This can be done as accelerometer is reading in data */
                Log.d(DEBUG_TAG, "Processing done");
                sensorDataCopy.clear();
            }
        }

        /**
         * Algorithm checks for peaks and increments number steps based on
         * peaks found... NOTE: It will not count peaks that were always
         * above threshold, meaning the peak must go above and then below
         * the threshold to be counted as a step
         */
        private void detectSteps() {

            for(int i = 0; i < SAMPLE_SIZE; i++) {

                numberSamplesToStep++; /** Allows for the calculation of the period */

                if(numberSamplesToStep * TIME_STEP > 2.0f) { /** We have stopped */
                    moving = false;
                }

                if(sensorDataCopy.get(i) > THRESHOLD) {
                    aboveThreshold = true;
                }
                else { /** Below threshold */
                    if(aboveThreshold) { /** Possible step detected */
                        aboveThreshold = false;

                        if(!moving) { /** This is the first step! */
                            numberSamplesToStep = 0;
                            steps++;
                            moving = true;
                            sendMessageToActivity(); /** Broadcast update */
                        }
                        else { /** We are moving! Need to check period */
                            if(numberSamplesToStep * TIME_STEP > 0.14f) { /** Want a certain frequency achieved */
                                numberSamplesToStep = 0; /** Reset counter */
                                steps++;
                                sendMessageToActivity();
                            }
                        }
                    }
                }
            }

        }
    }
}
